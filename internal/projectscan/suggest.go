package projectscan

import (
	"fmt"
	"strings"

	"github.com/luckyPipewrench/pipelock/internal/config"
	"gopkg.in/yaml.v3"
)

// buildSuggestion creates a SuggestCfg from the scan report.
func buildSuggestion(r *Report) *SuggestCfg {
	s := &SuggestCfg{
		Preset:     presetForAgent(r.AgentType),
		GitEnabled: hasGitRepo(r.Dir),
	}

	// Collect ecosystem domains not already in the preset
	for _, eco := range r.Ecosystems {
		if domains, ok := ecosystemDomains[eco]; ok {
			s.ExtraDomains = append(s.ExtraDomains, domains...)
		}
	}

	return s
}

func presetForAgent(agent string) string {
	switch agent {
	case AgentClaudeCode:
		return AgentClaudeCode
	case AgentCursor:
		return AgentCursor
	default:
		return AgentGeneric
	}
}

// BuildConfig creates a full config.Config from the suggestion.
func (s *SuggestCfg) BuildConfig() *config.Config {
	cfg := config.Defaults()

	// Apply preset-specific settings
	switch s.Preset {
	case AgentClaudeCode:
		cfg.FetchProxy.Monitoring.EntropyThreshold = 5.0
		cfg.FetchProxy.Monitoring.MaxURLLength = 4096
		cfg.FetchProxy.Monitoring.MaxReqPerMinute = 120
		cfg.ResponseScanning.Action = "block"
		cfg.FetchProxy.Monitoring.Blocklist = append(cfg.FetchProxy.Monitoring.Blocklist,
			"*.webhook.site", "*.pipedream.net")
	case AgentCursor:
		cfg.FetchProxy.Monitoring.EntropyThreshold = 5.0
		cfg.FetchProxy.Monitoring.MaxURLLength = 4096
		cfg.FetchProxy.Monitoring.MaxReqPerMinute = 120
		cfg.ResponseScanning.Action = "block"
		cfg.FetchProxy.Monitoring.Blocklist = append(cfg.FetchProxy.Monitoring.Blocklist,
			"*.webhook.site", "*.pipedream.net")
	default:
		// generic-agent: warn mode, tolerant thresholds
		cfg.FetchProxy.Monitoring.EntropyThreshold = 5.5
		cfg.FetchProxy.Monitoring.MaxURLLength = 4096
		cfg.FetchProxy.Monitoring.MaxReqPerMinute = 120
	}

	// Merge extra domains
	seen := make(map[string]bool)
	for _, d := range cfg.APIAllowlist {
		seen[d] = true
	}
	for _, d := range s.ExtraDomains {
		if !seen[d] {
			cfg.APIAllowlist = append(cfg.APIAllowlist, d)
			seen[d] = true
		}
	}

	// Add extra DLP patterns
	cfg.DLP.Patterns = append(cfg.DLP.Patterns, s.ExtraDLP...)

	// Enable git protection if repo detected
	if s.GitEnabled {
		cfg.GitProtection.Enabled = true
	}

	return cfg
}

// RenderYAML marshals the suggested config to YAML with a descriptive header.
func (s *SuggestCfg) RenderYAML() (string, error) {
	cfg := s.BuildConfig()

	data, err := yaml.Marshal(cfg)
	if err != nil {
		return "", fmt.Errorf("marshaling config: %w", err)
	}

	var b strings.Builder
	b.WriteString("# Pipelock config â€” generated by pipelock audit\n")
	b.WriteString(fmt.Sprintf("# Base preset: %s\n", s.Preset))
	if len(s.ExtraDomains) > 0 {
		b.WriteString(fmt.Sprintf("# Added domains for: %s\n", strings.Join(uniqueEcosystems(s.ExtraDomains), ", ")))
	}
	if s.GitEnabled {
		b.WriteString("# Git protection: enabled (repository detected)\n")
	}
	b.WriteString("# Review and rename to pipelock.yaml when ready.\n\n")
	b.Write(data)

	return b.String(), nil
}

func uniqueEcosystems(domains []string) []string {
	seen := make(map[string]bool)
	var result []string
	for eco, doms := range ecosystemDomains {
		for _, d := range domains {
			for _, ed := range doms {
				if d == ed && !seen[eco] {
					seen[eco] = true
					result = append(result, eco)
				}
			}
		}
	}
	return result
}
