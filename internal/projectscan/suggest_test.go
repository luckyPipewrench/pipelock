package projectscan

import (
	"strings"
	"testing"

	"github.com/luckyPipewrench/pipelock/internal/config"
)

func TestPresetForAgent(t *testing.T) {
	tests := []struct {
		agent string
		want  string
	}{
		{AgentClaudeCode, AgentClaudeCode},
		{AgentCursor, AgentCursor},
		{AgentCrewAI, AgentGeneric},
		{AgentLangGraph, AgentGeneric},
		{AgentAutoGen, AgentGeneric},
		{AgentGeneric, AgentGeneric},
	}
	for _, tt := range tests {
		if got := presetForAgent(tt.agent); got != tt.want {
			t.Errorf("presetForAgent(%q) = %q, want %q", tt.agent, got, tt.want)
		}
	}
}

func TestBuildConfig_ClaudeCode(t *testing.T) {
	s := &SuggestCfg{
		Preset:     AgentClaudeCode,
		GitEnabled: true,
	}
	cfg := s.BuildConfig()

	if cfg.FetchProxy.Monitoring.EntropyThreshold != 5.0 {
		t.Errorf("entropy threshold = %.1f, want 5.0", cfg.FetchProxy.Monitoring.EntropyThreshold)
	}
	if cfg.ResponseScanning.Action != "block" { //nolint:goconst // test value
		t.Errorf("response action = %q, want block", cfg.ResponseScanning.Action)
	}
	if !cfg.GitProtection.Enabled {
		t.Error("expected git protection enabled")
	}
	if cfg.FetchProxy.Monitoring.MaxURLLength != 4096 {
		t.Errorf("max URL length = %d, want 4096", cfg.FetchProxy.Monitoring.MaxURLLength)
	}
}

func TestBuildConfig_Generic(t *testing.T) {
	s := &SuggestCfg{
		Preset:     AgentGeneric,
		GitEnabled: false,
	}
	cfg := s.BuildConfig()

	if cfg.FetchProxy.Monitoring.EntropyThreshold != 5.5 {
		t.Errorf("entropy threshold = %.1f, want 5.5", cfg.FetchProxy.Monitoring.EntropyThreshold)
	}
	if cfg.GitProtection.Enabled {
		t.Error("expected git protection disabled")
	}
}

func TestBuildConfig_ExtraDomains(t *testing.T) {
	s := &SuggestCfg{
		Preset:       AgentGeneric,
		ExtraDomains: []string{"pypi.org", "*.python.org"},
	}
	cfg := s.BuildConfig()

	found := make(map[string]bool)
	for _, d := range cfg.APIAllowlist {
		found[d] = true
	}
	if !found["pypi.org"] {
		t.Error("expected pypi.org in allowlist")
	}
	if !found["*.python.org"] {
		t.Error("expected *.python.org in allowlist")
	}
}

func TestBuildConfig_NoDuplicateDomains(t *testing.T) {
	s := &SuggestCfg{
		Preset: AgentGeneric,
		// This domain already exists in Defaults()
		ExtraDomains: []string{"registry.npmjs.org"},
	}
	cfg := s.BuildConfig()

	count := 0
	for _, d := range cfg.APIAllowlist {
		if d == "registry.npmjs.org" {
			count++
		}
	}
	if count != 1 {
		t.Errorf("expected exactly 1 occurrence of registry.npmjs.org, got %d", count)
	}
}

func TestBuildConfig_ExtraDLP(t *testing.T) {
	s := &SuggestCfg{
		Preset: AgentGeneric,
		ExtraDLP: []config.DLPPattern{
			{Name: "Stripe Key", Regex: `sk_live_[a-zA-Z0-9]{24}`, Severity: "critical"},
		},
	}
	cfg := s.BuildConfig()

	found := false
	for _, p := range cfg.DLP.Patterns {
		if p.Name == "Stripe Key" {
			found = true
		}
	}
	if !found {
		t.Error("expected Stripe Key in DLP patterns")
	}
}

func TestRenderYAML(t *testing.T) {
	s := &SuggestCfg{
		Preset:       AgentClaudeCode,
		GitEnabled:   true,
		ExtraDomains: []string{"pypi.org"},
	}

	yaml, err := s.RenderYAML()
	if err != nil {
		t.Fatalf("RenderYAML error: %v", err)
	}

	if !strings.Contains(yaml, "generated by pipelock audit") {
		t.Error("expected header comment")
	}
	if !strings.Contains(yaml, "claude-code") {
		t.Error("expected preset name in header")
	}
	if !strings.Contains(yaml, "Git protection: enabled") {
		t.Error("expected git protection note in header")
	}
	if !strings.Contains(yaml, "version:") {
		t.Error("expected YAML config content")
	}
}

func TestRenderYAML_NoExtras(t *testing.T) {
	s := &SuggestCfg{
		Preset: AgentGeneric,
	}

	yaml, err := s.RenderYAML()
	if err != nil {
		t.Fatalf("RenderYAML error: %v", err)
	}

	if strings.Contains(yaml, "Added domains") {
		t.Error("should not have domain comment when no extras")
	}
	if strings.Contains(yaml, "Git protection: enabled") {
		t.Error("should not have git comment when disabled")
	}
}

func TestBuildSuggestion(t *testing.T) {
	// Build a minimal report
	r := &Report{
		Dir:        t.TempDir(),
		AgentType:  AgentClaudeCode,
		Ecosystems: []string{EcoPip, EcoNPM},
	}

	s := buildSuggestion(r)
	if s.Preset != AgentClaudeCode {
		t.Errorf("preset = %q, want claude-code", s.Preset)
	}
	if len(s.ExtraDomains) == 0 {
		t.Error("expected extra domains for pip + npm ecosystems")
	}
}

func TestUniqueEcosystems(t *testing.T) {
	domains := []string{"pypi.org", "*.python.org", "registry.npmjs.org", "*.npmjs.com"}
	result := uniqueEcosystems(domains)

	found := make(map[string]bool)
	for _, r := range result {
		found[r] = true
	}
	if !found[EcoPip] {
		t.Error("expected pip ecosystem")
	}
	if !found[EcoNPM] {
		t.Error("expected npm ecosystem")
	}
}

func TestBuildConfig_Cursor(t *testing.T) {
	s := &SuggestCfg{
		Preset:     AgentCursor,
		GitEnabled: false,
	}
	cfg := s.BuildConfig()

	if cfg.FetchProxy.Monitoring.EntropyThreshold != 5.0 {
		t.Errorf("entropy threshold = %.1f, want 5.0", cfg.FetchProxy.Monitoring.EntropyThreshold)
	}
	if cfg.ResponseScanning.Action != "block" {
		t.Errorf("response action = %q, want block", cfg.ResponseScanning.Action)
	}
}
